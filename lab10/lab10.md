# Практика 10. Сетевой уровень

## Wireshark: IP (8 баллов)
Для работы вам понадобится программа traceroute. При работе программа traceroute сначала
отправляет одну или несколько дейтаграмм, причем в поле предписанного времени жизни (TTL) в
IP-заголовке таких дейтаграмм устанавливается значение 1; затем программа посылает одну или
несколько дейтаграмм по тому же адресу, но в поле TTL уже ставится значение 2; далее процесс
повторяется с изменением значения TTL на 3 и т. д.

Маршрутизатор должен уменьшать на единицу значение в поле TTL каждой дейтаграммы,
которую получает. Если значение в поле TTL достигает 0, маршрутизатор возвращает 
ICMP-сообщение (тип 11 – значение TTL исчерпано) хосту-отправителю.

Таким образом хост, на котором выполняется программа traceroute, может узнать
идентификационные данные всех маршрутизаторов между собой и хостом назначения X. Для
этого ему достаточно свериться с IP-адресами источников дейтаграмм, содержащих сообщения
протокола ICMP о том, что их значение TTL достигло нуля.

Вам необходима версия программы traceroute, которая умеет рассылать дейтаграммы разной длины.
- Если вы работаете с Windows:
  Программа tracert, предоставляемая в Windows, не позволяет изменять размер сообщения 
  эхо-запроса ICMP (ping), посылаемого программой tracert. Для этого используйте программу
  [pingplotter](https://www.pingplotter.com/). Размер сообщения ICMP с эхо-запросом можно установить явно,
  выбрав команду меню Edit => Options => Default Settings => Engine, а затем указав значение в поле
  Packet Size.
- Если вы работаете с Unix:
  При помощи команды traceroute из операционных систем Unix можно явно устанавливать размер
  UDP-дейтаграммы, отправляемой на хост назначения (в Unix системах вместо ICMP используется
  UDP). Это значение вводится в командную строку traceroute сразу же за именем или адресом
  хоста назначения. Например, чтобы отправить дейтаграммы traceroute размером 2000 байт на
  адрес gaia.cs.umass.edu, может использоваться следующая команда:
  `traceroute gaia.cs.umass.edu 2000`

#### Подготовка
1. Запустите программу Wireshark и начните захват пакетов.
2. Запустите pingplotter, выберите имя какого-либо целевого хоста (например, akamai.com).
   Запустите трассировку для размера пакета Packet Size = 56 байт.
3. Остановите трассировку Wireshark.

#### Вопросы
В вашей трассе вы должны видеть ряд эхо-запросов по протоколу ICMP (при работе с
Windows) или UDP-сегмент (в случае с Unix).
1. Выберите первое ICMP-сообщение эхо-запроса, отправленное вашим компьютером, и
   раскройте часть информации о пакете Internet Protocol в окне подробной информации.
   Каков IP-адрес вашего компьютера?
   - `Source Address: 192.168.0.127`
2. Найдите заголовок IP-пакета. Какое значение указано здесь в поле протокола верхнего уровня?
   - `Protocol: ICMP (1)`
3. Сколько байт в IP-заголовке? Сколько байт приходится на полезную нагрузку IP-дейтаграммы?
   - 20 байт
   - $56 - 20 = 36$ байт
   - ![](images/11.png)
4. Отсортируйте отслеженные пакеты по их исходному IP-адресу; для этого щелкните по заголовку столбца Source. Выберите первое сообщение эхо-запроса, отосланное вашим компьютером по протоколу ICMP, и раскройте раздел Internet Protocol.
   1. Какие поля IP-дейтаграммы всегда изменяются от одной дейтаграммы к следующей в рамках одной последовательности ICMP-сообщений, отсылаемых компьютером (последовательность – это все сообщения, которые отправляются до конечного хоста)?
      - `TTL`, `Identification`, `Header checksum`
   2. Какие поля не меняются? Какие поля должны оставаться неизменными? Какие поля должны изменяться? (в рамках одного запуска утилиты)
       - `Version`,  `Header length`, `Differentiated Services Field`, `Total length`, `Protocol`, `Source address`, `Destination address`
      - Ну, порассуждать только могу из тех, которые в эксперименте не поменялись:
        - `Version`, `Header length` - будет забавно, если в процессе передачи поменяется версия протокола IP, и длина заголовка. **Не будут изменяться**
        - `Differentiated Services Field` - я, как понял, это поле связано с настройками качества обслуживания _(типа управление и контроль трафиком с целью обеспечения какой-нибудь производительности/надежности/etc)_ в сетях, используяющих IP-протокол. Поэтому, скорее всего, оно будет неизменным в рамках эксперимента. **Не будет изменяться**
        - `Total length` - длина всего пакета, включая IP-заголовок. Мы в самой программе его задаем. **Не будет изменяться**
        - `Protocol` - номер протокола. **Не будут изменяться**
        - `Source / Destination address` - IP-адрес отправителя / получателя. **Не будут изменяться**
      - `TTL`, `Identification`, `Header checksum`
   3. Как изменяется значение поля Identification IP-дейтаграммы с каждым последующим эхо-запросом? Есть ли какая-либо закономерность?
      - Ну, увеличивается
      - Не знаю, насколько закономерность, но увеличивается на 1 с каждым эхо-запросом
5. Какое значение содержится в поле Identification (Идентификация), а какое – в поле TTL
   (выберите какой-либо один пакет ICMP)?
   - `Identification: 0x4f77 (20343)`
   - `TTL: 64`
   - ![](images/12.png)
6. Остаются ли эти значения (Identification и TTL) неизменными во всех сообщениях
   протокола ICMP, где содержится информация об истечении предписанного времени
   жизни; рассмотрите только те из таких сообщений, которые поступили на компьютер с
   ближайшего (первого транзитного) маршрутизатора.
   - `Identification` меняется, `TTL` остается тем же
7. Найдите серии откликов ICMP, в которых содержатся сообщения об истечении
   предписанного времени жизни (time-to-live exceeded). Выберите один из пакетов.
   Какое значение содержится в поле Identification (Идентификация), а какое – в поле TTL?
   - `Identification: 0xd765 (55141)`
   - `Time to Live: 252`
   - ![](images/13.png)
8. **Фрагментация**. Остановите захват пакетов в Wireshark. Измените размер пакета Packet Size = 3500 байт. Снова запустите захват пакетов в Wireshark и перезапустите трассировку. (Для Unix заново запустите traceroute с длиной пакета 3500 байт). Найдите первое сообщение протокола ICMP с эхо-запросом, поступившее на ваш компьютер (с уже измененным размером пакета).
   1. Было ли это сообщение фрагментировано между двумя или более IP-дейтаграммами? 
      Если да, то сколько фрагментов было создано?
      - `3 IPv4 Fragments (3480 bytes)`
   2. Какие поля IP-заголовка изменяются в разных фрагментах?
      - `Fragment offset`, `Header checksum`, `Flags`, `Total length` _(ну не прям меняется: так-то все ровно, но в последнем куске просто остаток может быть объемом меньше)_
      
      - Про `Flags` небольшое отступление, что там меняется:
         - `Flags` - эти флаги в IP-протоколе служат для фрагментации пакетов:
            - Первый бит всегда 0. Он зарезервирован
            - Второй называется `Don't fragment bit`. Если установлен `1`, то он указывает, что пакет не должен фрагментироваться
            - Последний называется `More fragments bit`. Если установлен `1`, то он указывает, что данный фрагмент не является последним, и за ним следуют другие фрагменты
          - В рамках этого эксперимента, у нас пакет размером, превышающим MTU. Поэтому мы его бьем на куски, а затем шлем их. Мы шлем, шлем _(`001`, `001`)_, и доходим до последнего куска. Там говорим, что больше нечего фрагментировать _(`000`)_
   3. ![](images/14.png) 

## Программирование.

### 1. Эхо-запросы через ICMP (8 баллов)
Реализуйте консольное приложение для эхо-запросов (пингования) с помощью ICMP-запросов и
ответов. Приложение отправляет ICMP-пакеты («эхо-запрос» или «пинг») на целевой хост и
слушает ICMP-ответы («эхо-ответ») от него. Обычно при получении ответов измеряется время
оборота (RTT), фиксируются потери пакетов и выводится статистическая сводка о полученных
ответах (минимальное, максимальное и среднее значение времени оборота, а в некоторых
версиях еще и стандартное отклонение от среднего).

Вам потребуется написать только клиентскую часть программы, а функциональные возможности,
необходимые на стороне сервера, встроены почти во все операционные системы.
Приложение должно отправлять эхо-запросы на определенный хост через одну секунду. Каждое
такое сообщение-запрос содержит данные, которые включают в себя отметку времени. После
отправки каждого пакета приложение ждет получения ответного сообщения в течение одной
секунды. Если ответа нет, то клиент предполагает, что пакет запроса или ответный пакет
были потеряны в сети (или целевой хост недоступен).

В этой работе необходимо будет разобраться с тем, как организовать проверку контрольных сумм
и создание заголовков для ICMP пакетов.

### Пролог
Я написал утилиту Ping, которая отправляет ICMP-запросы _(4 запроса по умолчанию)_, получает ответы и вычисляет статистики, связанные с RTT и пакетами.
В целом, можно в процессе запросов можно прерваться и выведется накопившаяся статистика.
Короче, пытался сделать как в Unix'е:

```
usage: ping.py [-h] [-c COUNT] [-t TIMEOUT] host

Ping utility for lab10

positional arguments:
  host                  Host to ping

options:
  -h, --help            show this help message and exit
  -c COUNT, --count COUNT
                        Number of requests to send
  -t TIMEOUT, --timeout TIMEOUT
                        Timeout in seconds
```

### Задание А (6 баллов) - DONE
Реализуйте приложение для эхо-запросов (пингования) с помощью ICMP-запросов и ответов.

Сделайте скриншоты результатов пингования **двух различных** хостов назначения, находящихся
**на разных континентах**.

### Задание Б (1 балл) - DONE
Организуйте вывод на консоль так, как это сделано в стандартной утилите ping: нужно вывести
минимальное, максимальное и среднее значение RTT в конце каждого ответа от сервера.
Дополнительно вычислите коэффициент потери пакетов (в процентах).

Хост назначения: `akamai.com`, Швеция:
```
PING akamai.com (23.216.134.145) 8 bytes of data.
36 bytes from 23.216.134.145: icmp_seq=1 ttl=56 time=18.559 ms
36 bytes from 23.216.134.145: icmp_seq=2 ttl=56 time=16.361 ms
36 bytes from 23.216.134.145: icmp_seq=3 ttl=56 time=15.555 ms
36 bytes from 23.216.134.145: icmp_seq=4 ttl=56 time=16.682 ms

--- akamai.com ping statistics ---
4 packets transmitted, 4 received, 0% packet loss   
rtt min/avg/max/mdev = 15.555/16.789/18.559/1.271 ms
```

Хост назначения: `stanford.edu`, США:
```
PING stanford.edu (171.67.215.200) 8 bytes of data.
36 bytes from 171.67.215.200: icmp_seq=1 ttl=241 time=178.860 ms
36 bytes from 171.67.215.200: icmp_seq=2 ttl=241 time=177.287 ms
36 bytes from 171.67.215.200: icmp_seq=3 ttl=241 time=177.562 ms
36 bytes from 171.67.215.200: icmp_seq=4 ttl=241 time=177.473 ms

--- stanford.edu ping statistics ---
4 packets transmitted, 4 received, 0% packet loss
rtt min/avg/max/mdev = 177.287/177.796/178.860/0.719 ms
```

### Задание В (1 балл) - DONE
Ваша программа обрабатывает только тайм-ауты в получении ICMP-ответов. Добавьте к ней
функционал анализа кодов ошибок протокола ICMP и вывод соответствующих результатов для
пользователя. Примерами кодов ошибок ICMP являются: 0 – сеть назначения недоступна, 1 – хост
назначения недоступен.

Приложите скриншот вывода одной из ошибок.

#### Демонстрация работы
```
PING 192.168.0.228 (192.168.0.228) 8 bytes of data.
Request timeout for icmp_seq 1
64 bytes from 192.168.0.127: Host unreachable
Request timeout for icmp_seq 3
64 bytes from 192.168.0.127: Host unreachable

--- 192.168.0.228 ping statistics ---
4 packets transmitted, 0 received, 100% packet loss
No packets received
```

### Справочная информация о протоколе ICMP

#### ICMP-заголовок

<table>
    <thead>
        <tr>
            <th>Биты</th>
            <th>160-167</th>
            <th>168-175</th>
            <th>176-183</th>
            <th>184-191</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td align="center"><b>160</B></td>
            <td align="center">Тип</td>
            <td align="center">Код</td>
            <td align="center" colspan=2>Контрольная сумма</td>
        </tr>
        <tr>
            <td align="center"><b>192</b></td>
            <td align="center" colspan=2>Идентификатор</td>
            <td align="center" colspan=2>Номер последовательности</td>
        </tr>
    </tbody>
</table>

ICMP-заголовок начинается после 160-го бита IP-заголовка
- Тип – тип сообщения ICMP
- Код – подтип заданного типа
- Контрольная сумма – вычисляемые для всего ICMP-пакета целиком данные для проверки
ошибок. При вычислении контрольной суммы значение поля полагается равным нулю
- Идентификатор – значение, возвращаемое в случае, когда сообщение является эхо-ответом
- Номер последовательности – значение, возвращаемое в случае, когда сообщение является
эхо-ответом

#### Эхо-запрос
Эхо-запрос – это сообщение ICMP, данные которого должны быть возвращены обратно в эхо-ответе от принимающего хоста.
- Тип ICMP для эхо-запроса равен 8.
- Код устанавливается в значение 0.
- Идентификатор и номер последовательности используются клиентом, чтобы
идентифицировать соответствующие друг другу пары запрос-ответ. На практике
большинство систем семейства Linux используют уникальный идентификатор для каждого
процесса пингования, а номер последовательности – увеличивающееся в течение этого
процесса число.
- Данные, полученные в эхо-запросе, должны полностью быть включены в эхо-ответ.

#### Эхо-ответ
Эхо-ответ – это сообщение ICMP, генерируемое в ответ на эхо-запрос.
- Тип ICMP и код для эхо-ответа устанавливаются в 0.
- Идентификатор и номер последовательности используются клиентом для определения
соответствия пар запрос-ответ.
- Данные, полученные в эхо-запросе, должны полностью быть включены в эхо-ответ.

### 2. Go back-N протокол (8 баллов)
Реализуйте протокол конвейерной передачи данных GBN. Продемонстрируйте работоспособность
вашего решения на примере консольного клиент-серверного приложения, в котором клиент
отправляет серверу файл с данными. Основные шаги при передаче и получении пакетов должны
выводиться в лог. По логу должно быть видно состояние клиента/сервера: какие пакеты находятся
в окне передачи, на какие получены подтверждения, на какие еще нет, а какие еще не переданы.

Приложите файлы с логами клиента и сервера или скрин работы программы.

Пример вывода на консоль приложения, которое было рассмотрено на практике: 

<img src="images/go-back-n.png" width=700 />

#### Демонстрация работы
todo
